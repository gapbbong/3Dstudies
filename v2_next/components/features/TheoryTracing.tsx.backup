
'use client';

import { useState, useRef, useEffect, useCallback } from 'react';
import { motion } from 'framer-motion';
import { useSecurity } from '@/hooks/useSecurity';

interface TheoryTracingProps {
    targetText: string;
    onComplete: () => void;
    isRecallMode?: boolean;
}

const ALL_KEYWORDS = ['FDM', 'SLA', 'DLP', 'SLS', 'FFF', 'G-Code', 'STL', '적층', '레이어', '필라멘트', '베드', '노즐', '익스트루더', '서포트', '슬라이싱', '큐라', '메쉬', '모델링', '출력', '베드', '안전', '수평', '레벨링'];

export default function TheoryTracing({ targetText, onComplete, isRecallMode = false }: TheoryTracingProps) {
    const [userInput, setUserInput] = useState('');
    const [accuracy, setAccuracy] = useState(0);
    const inputRef = useRef<HTMLTextAreaElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);

    const isKeyword = useCallback((word: string) => {
        const clean = word.replace(/[.,!?()[\]]/g, '');
        return ALL_KEYWORDS.includes(clean) || clean.length >= 4;
    }, []);

    // ... handleAutoReplace and other logic ...

    useEffect(() => {
        // ... drawing logic ...
    }, [userInput, targetText, isRecallMode, isKeyword]);
    const handleAutoReplace = (text: string, start: number) => {
        const transformed = text
            .replace(/--/g, '→')
            .replace(/\.\./g, '·');

        if (transformed !== text) {
            setUserInput(transformed);
            requestAnimationFrame(() => {
                const input = inputRef.current;
                if (input) {
                    const offset = text.length - transformed.length;
                    input.setSelectionRange(start - offset, start - offset);
                }
            });
        }
    };

    const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
        const val = e.target.value;
        const start = e.target.selectionStart;
        setUserInput(val);
        handleAutoReplace(val, start);

        // Calculate progress based on character matching, not just length
        let matchedChars = 0;
        const minLength = Math.min(val.length, targetText.length);
        for (let i = 0; i < minLength; i++) {
            if (val[i] === targetText[i]) {
                matchedChars++;
            }
        }
        const progress = Math.min(100, Math.floor((matchedChars / targetText.length) * 100));
        setAccuracy(progress);
    };

    const handleSubmit = () => {
        if (accuracy >= 98) {
            onComplete();
        } else {
            alert(`아직 ${accuracy}% 완성되었습니다. 98% 이상 채워주세요!`);
        }
    };

    useSecurity({
        onEnter: (e: KeyboardEvent) => {
            if (e?.ctrlKey) handleSubmit();
        },
        preventCopy: true
    });

    // Draw text to Canvas for anti-copy and anti-OCR protection
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d', { alpha: true });
        if (!ctx) return;

        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        ctx.clearRect(0, 0, rect.width, rect.height);

        const fontSize = 20;
        const lineHeight = 32;
        const padding = 24;
        const letterSpacing = 1;

        // Use standard sans-serif font stack
        const fontStack = 'Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", sans-serif';
        ctx.font = `500 ${fontSize}px ${fontStack}`;
        ctx.textBaseline = 'top';
        ctx.imageSmoothingEnabled = true;

        let x = padding;
        let y = padding;
        const maxWidth = rect.width - (padding * 2);

        // Character-by-character rendering for Hangul IME support
        for (let i = 0; i < targetText.length; i++) {
            const targetChar = targetText[i];
            const userChar = userInput[i];

            // Handle newlines
            if (targetChar === '\n') {
                x = padding;
                y += lineHeight;
                // Add extra spacing for paragraph breaks
                if (i > 0 && targetText[i - 1] === '\n') {
                    y += lineHeight * 0.5;
                }
                continue;
            }

            const charWidth = ctx.measureText(targetChar).width + letterSpacing;

            // Wrap to next line if needed
            if (x + charWidth > maxWidth && x !== padding) {
                x = padding;
                y += lineHeight;
            }

            // Draw background (target text) in gray
            ctx.fillStyle = '#334155'; // slate-700
            ctx.fillText(targetChar, x, y);

            // Draw user input overlay
            if (userChar !== undefined) {
                const isCurrentlyTyping = i === userInput.length - 1;

                if (userChar === targetChar) {
                    ctx.fillStyle = '#60a5fa'; // blue-400 (correct)
                } else if (isCurrentlyTyping) {
                    ctx.fillStyle = '#ffffff'; // white (currently typing, including ㄱ, ㅏ, etc.)
                } else {
                    ctx.fillStyle = '#ef4444'; // red-400 (wrong)
                }

                ctx.fillText(userChar, x, y);
            }

            x += charWidth;
        }

        // Add strong noise and rotation to prevent OCR
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 0) { // Only add noise to non-transparent pixels
                const noise = (Math.random() - 0.5) * 8; // Increased noise
                data[i] += noise;     // R
                data[i + 1] += noise; // G
                data[i + 2] += noise; // B
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }, [userInput, targetText, isRecallMode, isKeyword]);

    return (
        <div className="w-full max-w-2xl mx-auto p-4 flex flex-col gap-4">
            <div className="relative w-full h-[480px] bg-slate-900 rounded-2xl border border-slate-700 overflow-hidden shadow-inner">
                <canvas
                    ref={canvasRef}
                    className="absolute inset-0 w-full h-full pointer-events-none select-none z-0"
                    style={{ imageRendering: 'auto' }}
                    aria-hidden="true"
                    role="presentation"
                />

                <textarea
                    ref={inputRef}
                    value={userInput}
                    onChange={handleChange}
                    className="absolute inset-0 bg-transparent p-6 text-xl leading-relaxed text-white whitespace-pre-wrap outline-none resize-none z-10 caret-blue-500 break-all"
                    style={{
                        fontFamily: 'Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", sans-serif',
                        letterSpacing: '1px',
                        color: 'transparent',
                        WebkitTextFillColor: 'transparent',
                        lineHeight: '32px',
                        padding: '24px'
                    }}
                    placeholder={isRecallMode ? "빈칸(■■)에 들어갈 내용을 채우며 입력하세요..." : "여기에 위 내용을 따라 적으세요..."}
                    autoFocus
                />
            </div>

            <div className="flex items-center justify-between px-2">
                <div className="flex items-center gap-4">
                    <div className="text-sm text-slate-400">
                        {isRecallMode ? '암기율' : '진행도'}: <span className="font-bold text-blue-400">{accuracy}%</span>
                    </div>
                    <div className="w-48 h-2 bg-slate-800 rounded-full overflow-hidden">
                        <motion.div
                            className={`h-full ${isRecallMode ? 'bg-yellow-500' : 'bg-blue-500'}`}
                            initial={{ width: 0 }}
                            animate={{ width: `${accuracy}%` }}
                        />
                    </div>
                </div>

                <div className="flex gap-2">
                    <button
                        onClick={handleSubmit}
                        className={`px-6 py-2 ${isRecallMode ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-blue-600 hover:bg-blue-500'} text-white rounded-lg font-bold transition-all disabled:opacity-50`}
                        disabled={accuracy < 98}
                    >
                        {isRecallMode ? '암기 완료' : '제출하기'} (Ctrl+Enter)
                    </button>
                </div>
            </div>

            <p className="text-xs text-slate-500 text-center mt-2">
                {isRecallMode
                    ? "※ 노란색 박스는 핵심 키워드입니다. 기억을 되살려 입력해보세요!"
                    : "※ --는 →로, ..은 ·으로 자동 변환됩니다."
                }
            </p>
        </div>
    );
}
